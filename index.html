<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Rose - Valentine's Day</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #1a0a1f 0%, #2d0a3f 50%, #1a0a1f 100%);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Surprise Overlay - Fully Responsive */
        .surprise-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, #2d1a2f 0%, #1a0a1f 100%);
            z-index: 100;
            transition: opacity 1.5s ease;
            pointer-events: auto;
            padding: 20px;
            overflow-y: auto; /* For very small screens */
        }

        .surprise-content {
            text-align: center;
            animation: float 3s infinite ease-in-out;
            width: 100%;
            max-width: 1000px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .valentine-question {
            font-size: clamp(1.8rem, 8vw, 3.5rem);
            color: #ffb6c1;
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.7);
            margin-bottom: clamp(20px, 5vh, 40px);
            letter-spacing: 2px;
            font-weight: normal;
            word-wrap: break-word;
            line-height: 1.3;
        }

        .button-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: clamp(20px, 5vw, 50px);
            margin-top: clamp(15px, 4vh, 30px);
            position: relative;
            flex-wrap: wrap;
            width: 100%;
            min-height: 150px; /* Space for moving button */
        }

        .btn {
            border: none;
            color: white;
            padding: clamp(12px, 2.5vw, 18px) clamp(30px, 6vw, 50px);
            font-size: clamp(1.2rem, 5vw, 1.8rem);
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Georgia', serif;
            font-weight: bold;
            letter-spacing: 2px;
            transition: transform 0.2s, box-shadow 0.2s, padding 0.2s, font-size 0.2s, left 0.1s ease, top 0.1s ease;
            border: 2px solid rgba(255, 255, 255, 0.5);
            min-width: clamp(120px, 30vw, 160px);
            white-space: nowrap;
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.3);
        }

        @media (max-width: 480px) {
            .btn {
                white-space: normal;
                min-width: 120px;
                padding: 12px 20px;
            }
        }

        .btn-yes {
            background: linear-gradient(45deg, #ff69b4, #ff1493);
            box-shadow: 0 0 30px rgba(255, 20, 147, 0.5);
            transform: scale(1);
            z-index: 10;
        }

        .btn-no {
            background: linear-gradient(45deg, #555, #333);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            transform: scale(1);
            position: absolute !important; /* Force absolute for movement */
            transition: transform 0.2s, box-shadow 0.2s, padding 0.2s, font-size 0.2s, left 0.15s ease-out, top 0.15s ease-out;
            z-index: 20;
        }

        .btn-yes:hover {
            transform: scale(1.05);
            box-shadow: 0 0 45px rgba(255, 105, 180, 0.8);
        }

        .heart-burst {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: radial-gradient(circle at center, rgba(255,105,180,0.2) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.5s;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
            100% { transform: translateY(0px); }
        }

        .info, .instructions {
            opacity: 0;
            transition: opacity 2s ease;
            pointer-events: none;
            position: absolute;
            z-index: 50;
            color: #ffb6c1;
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
        }

        .info {
            top: 20px;
            left: 20px;
            font-size: clamp(0.8rem, 4vw, 1.1rem);
        }

        .instructions {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(0.7rem, 3.5vw, 0.95rem);
            text-align: center;
            width: 90%;
        }

        .info.visible, .instructions.visible {
            opacity: 1;
            pointer-events: auto;
        }

        .tiny-heart {
            position: absolute;
            color: #ff69b4;
            font-size: 20px;
            animation: floatUp 4s linear forwards;
            z-index: 200;
            pointer-events: none;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(0.5); opacity: 1; }
            100% { transform: translateY(-100px) scale(1.2); opacity: 0; }
        }

        .success-message {
            color: #ffb6c1;
            font-size: clamp(1.5rem, 6vw, 2rem);
            margin-top: 30px;
            text-shadow: 0 0 15px rgba(255, 105, 180, 0.7);
            animation: pulse 1.5s infinite;
            width: 100%;
            word-wrap: break-word;
        }

        @keyframes pulse {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.8; transform: scale(1); }
        }

        /* Responsive canvas container */
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        h1 {
            color: #ff69b4;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 105, 180, 0.6);
        }

        /* Landscape orientation adjustments */
        @media (max-width: 768px) and (orientation: landscape) {
            .surprise-content {
                flex-direction: row;
                flex-wrap: wrap;
            }
            .valentine-question {
                font-size: clamp(1.5rem, 5vw, 2.5rem);
                width: 100%;
            }
            .button-container {
                min-height: 120px;
            }
        }
    </style>
</head>
<body>
    <!-- Surprise Overlay with Valentine Question and Yes/No Buttons -->
    <div id="surpriseOverlay" class="surprise-overlay">
        <div class="surprise-content">
            <h1 class="valentine-question">Will you be my Valentine?</h1>
            <div class="button-container" id="buttonContainer">
                <button id="yesBtn" class="btn btn-yes"> Yes</button>
                <button id="noBtn" class="btn btn-no">No</button>
            </div>
            <div id="successMessage" style="display: none;" class="success-message"></div>
        </div>
        <div id="heartBurst" class="heart-burst"></div>
    </div>

    <!-- Canvas for Three.js -->
    <div id="canvas"></div>


    <script>
        // ============================================
        // PLAYFUL YES/NO BUTTON LOGIC - FULLY RESPONSIVE
        // ============================================
        const overlay = document.getElementById('surpriseOverlay');
        const yesBtn = document.getElementById('yesBtn');
        const noBtn = document.getElementById('noBtn');
        const buttonContainer = document.getElementById('buttonContainer');
        const successMessage = document.getElementById('successMessage');
        const infoText = document.getElementById('infoText');
        const instructionsText = document.getElementById('instructionsText');
        const heartBurst = document.getElementById('heartBurst');

        // Yes button size tracking
        let yesButtonScale = 1;
        let noButtonScale = 1;
        let noButtonClickCount = 0;

        // Responsive boundaries update
        function updateContainerDimensions() {
            // Ensure no button stays within container on resize
            if (noBtn.style.position === 'absolute') {
                const containerRect = buttonContainer.getBoundingClientRect();
                const noBtnRect = noBtn.getBoundingClientRect();
                
                let left = parseFloat(noBtn.style.left) || 0;
                let top = parseFloat(noBtn.style.top) || 0;
                
                // Clamp values to stay inside
                const maxX = Math.max(0, containerRect.width - noBtnRect.width - 20);
                const maxY = Math.max(0, containerRect.height - noBtnRect.height - 20);
                
                left = Math.min(Math.max(left, 0), maxX);
                top = Math.min(Math.max(top, 0), maxY);
                
                noBtn.style.left = left + 'px';
                noBtn.style.top = top + 'px';
            }
        }

        // Create floating hearts effect
        function createFloatingHeart() {
            const heart = document.createElement('span');
            heart.innerHTML = '❤️';
            heart.className = 'tiny-heart';
            heart.style.left = Math.random() * 100 + '%';
            heart.style.top = '50%';
            heart.style.fontSize = (Math.random() * 30 + 20) + 'px';
            heart.style.animationDuration = (Math.random() * 3 + 3) + 's';
            heart.style.opacity = Math.random() * 0.7 + 0.3;
            document.body.appendChild(heart);

            setTimeout(() => {
                heart.remove();
            }, 6000);
        }

        // Function to move No button to random position (responsive)
        function moveNoButton() {
            const containerRect = buttonContainer.getBoundingClientRect();
            const noBtnRect = noBtn.getBoundingClientRect();
            
            // Calculate boundaries to keep button visible
            const maxX = Math.max(0, containerRect.width - noBtnRect.width - 20);
            const maxY = Math.max(0, containerRect.height - noBtnRect.height - 20);
            
            // Random position within container
            let randomX, randomY;
            
            if (maxX > 0 && maxY > 0) {
                randomX = Math.random() * maxX;
                randomY = Math.random() * maxY;
            } else {
                // Fallback positions if container is too small
                randomX = Math.max(0, (containerRect.width - noBtnRect.width) / 2);
                randomY = Math.max(0, (containerRect.height - noBtnRect.height) / 2);
            }
            
            // Apply random position (relative to container)
            noBtn.style.position = 'absolute';
            noBtn.style.left = randomX + 'px';
            noBtn.style.top = randomY + 'px';
        }

        // Initial placement of No button
        function initButtonPositions() {
            noBtn.style.position = 'absolute';
            // Wait for container to be rendered
            setTimeout(() => {
                const containerRect = buttonContainer.getBoundingClientRect();
                const yesBtnRect = yesBtn.getBoundingClientRect();
                
                // Place No button to the right of Yes button initially
                let left = yesBtnRect.width + 50;
                let top = 0;
                
                const maxX = Math.max(0, containerRect.width - noBtn.offsetWidth - 20);
                const maxY = Math.max(0, containerRect.height - noBtn.offsetHeight - 20);
                
                left = Math.min(left, maxX);
                top = Math.min(top, maxY);
                
                noBtn.style.left = left + 'px';
                noBtn.style.top = top + 'px';
            }, 50);
        }

        // No button click handler - it runs away and shrinks
        noBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // Increment click count
            noButtonClickCount++;
            
            // Create floating hearts (misery loves company)
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    createFloatingHeart();
                }, i * 20);
            }
            
            // Shrink No button (but not below a minimum size)
            noButtonScale = Math.max(0.35, noButtonScale * 0.9);
            noBtn.style.transform = `scale(${noButtonScale})`;
            noBtn.style.padding = `${12 * noButtonScale}px ${30 * noButtonScale}px`;
            noBtn.style.fontSize = `${1.2 * noButtonScale}rem`;
            noBtn.style.minWidth = `${120 * noButtonScale}px`;
            
            // Make Yes button bigger and bigger
            yesButtonScale += 0.15;
            yesBtn.style.transform = `scale(${yesButtonScale})`;
            yesBtn.style.padding = `${12 * yesButtonScale}px ${30 * yesButtonScale}px`;
            yesBtn.style.fontSize = `${1.2 * yesButtonScale}rem`;
            yesBtn.style.minWidth = `${120 * yesButtonScale}px`;
            yesBtn.style.boxShadow = `0 0 ${30 * yesButtonScale}px rgba(255, 20, 147, 0.5)`;
            
            // Move No button to random position
            moveNoButton();
            
            // Add playful messages after many attempts
            if (noButtonClickCount === 3) {
                noBtn.textContent = 'Are you sure?';
            } else if (noButtonClickCount === 5) {
                noBtn.textContent = 'Really?';
            } else if (noButtonClickCount === 7) {
                noBtn.textContent = 'Please?';
            } else if (noButtonClickCount === 10) {
                noBtn.textContent = 'You can\'t escape!';
            } else if (noButtonClickCount === 12) {
                noBtn.textContent = 'Just say Yes!';
            }
        });

        // Yes button click handler - reveal the rose
        yesBtn.addEventListener('click', function() {
            // Success message
            successMessage.style.display = 'block';
            successMessage.textContent = 'You said Yes!';
            
            // Create massive heart burst
            heartBurst.style.opacity = '1';
            for (let i = 0; i < 80; i++) {
                setTimeout(() => {
                    createFloatingHeart();
                }, i * 20);
            }
            
            // Initialize rose
            initRose();
            
            // Fade out overlay after a brief delay
            setTimeout(() => {
                overlay.style.opacity = '0';
                overlay.style.pointerEvents = 'none';
                
                // Show info text with fade in
                infoText.classList.add('visible');
                instructionsText.classList.add('visible');
                
                // Hide overlay after fade
                setTimeout(() => {
                    overlay.style.display = 'none';
                }, 1500);
            }, 800);
        });

        // ============================================
        // RESPONSIVE HANDLERS
        // ============================================
        // Update button positions on resize
        window.addEventListener('resize', function() {
            if (overlay.style.display !== 'none') {
                initButtonPositions();
            }
            updateContainerDimensions();
            
            // Update camera aspect ratio
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });

        // Touch events for mobile
        noBtn.addEventListener('touchstart', function(e) {
            e.preventDefault();
            // Trigger same behavior as click
            const clickEvent = new MouseEvent('click', {
                view: window,
                bubbles: true,
                cancelable: true
            });
            noBtn.dispatchEvent(clickEvent);
        });

        yesBtn.addEventListener('touchstart', function(e) {
            e.preventDefault();
            yesBtn.click();
        });

        // Initialize button positions on load
        window.addEventListener('load', function() {
            initButtonPositions();
        });

        // ============================================
        // THREE.JS ROSE SCENE (unchanged, but made responsive)
        // ============================================
        let scene, camera, renderer, rose, backgroundElements, lastTime;
        let isRoseInitialized = false;

        function initRose() {
            if (isRoseInitialized) return;
            isRoseInitialized = true;

            // ============================================
            // SCENE SETUP
            // ============================================
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x0a0a1a, 1);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit for performance
            
            const canvasElement = document.getElementById('canvas');
            canvasElement.innerHTML = ''; // Clear any existing canvas
            canvasElement.appendChild(renderer.domElement);
            
            // Responsive camera position based on aspect ratio
            if (window.innerWidth < 600) {
                camera.position.z = 7;
                camera.position.y = 0.5;
            } else {
                camera.position.z = 6;
                camera.position.y = 0;
            }
            camera.lookAt(0, 0.5, 0);

            // ============================================
            // ROMANTIC BACKGROUND
            // ============================================
            function createBackground() {
                // Distant starfield
                const starGeometry = new THREE.BufferGeometry();
                const starCount = window.innerWidth < 600 ? 1000 : 2000; // Fewer stars on mobile
                const starPositions = new Float32Array(starCount * 3);
                const starColors = new Float32Array(starCount * 3);
                
                for (let i = 0; i < starCount * 3; i += 3) {
                    starPositions[i] = (Math.random() - 0.5) * 200;
                    starPositions[i+1] = (Math.random() - 0.5) * 200;
                    starPositions[i+2] = (Math.random() - 0.8) * 200 - 50;
                    
                    const colorVal = Math.random();
                    if (colorVal < 0.6) {
                        starColors[i] = 1.0; starColors[i+1] = 1.0; starColors[i+2] = 1.0;
                    } else if (colorVal < 0.8) {
                        starColors[i] = 1.0; starColors[i+1] = 0.8; starColors[i+2] = 0.9;
                    } else {
                        starColors[i] = 1.0; starColors[i+1] = 0.9; starColors[i+2] = 0.6;
                    }
                }
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
                
                const starMaterial = new THREE.PointsMaterial({
                    size: window.innerWidth < 600 ? 0.2 : 0.25,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                
                const stars = new THREE.Points(starGeometry, starMaterial);
                scene.add(stars);
                
                // Additional layer of twinkling stars
                const twinkleGeo = new THREE.BufferGeometry();
                const twinkleCount = window.innerWidth < 600 ? 400 : 800;
                const twinklePositions = [];
                for (let i = 0; i < twinkleCount; i++) {
                    twinklePositions.push((Math.random() - 0.5) * 150);
                    twinklePositions.push((Math.random() - 0.5) * 150);
                    twinklePositions.push((Math.random() - 0.8) * 150 - 30);
                }
                twinkleGeo.setAttribute('position', new THREE.Float32BufferAttribute(twinklePositions, 3));
                const twinkleMat = new THREE.PointsMaterial({
                    color: 0xffaacc,
                    size: window.innerWidth < 600 ? 0.12 : 0.15,
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });
                const twinkles = new THREE.Points(twinkleGeo, twinkleMat);
                scene.add(twinkles);
                
                // Heart-shaped floating particles (fewer on mobile)
                const heartParticleGeo = new THREE.SphereGeometry(0.08, 4, 4);
                const heartParticleMat = new THREE.MeshStandardMaterial({
                    color: 0xff99bb,
                    emissive: 0x550033,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.7
                });
                
                const heartCount = window.innerWidth < 600 ? 4 : 7;
                for (let h = 0; h < heartCount; h++) {
                    const scale = 2 + Math.random() * 3;
                    const xOffset = (Math.random() - 0.5) * 40;
                    const yOffset = (Math.random() - 0.5) * 30;
                    const zOffset = -70 + Math.random() * 40;
                    
                    for (let i = 0; i < 30; i++) {
                        const heartParticle = new THREE.Mesh(heartParticleGeo, heartParticleMat.clone());
                        const t = Math.PI * 2 * (i / 30);
                        const x = 16 * Math.pow(Math.sin(t), 3);
                        const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                        
                        heartParticle.position.set(
                            x * 0.1 * scale/2 + xOffset,
                            y * 0.1 * scale/2 + yOffset,
                            zOffset
                        );
                        heartParticle.scale.setScalar(0.5 + Math.random() * 0.5);
                        heartParticle.castShadow = false;
                        heartParticle.receiveShadow = false;
                        scene.add(heartParticle);
                    }
                }
                
                return { stars, twinkles };
            }

            backgroundElements = createBackground();

            // ============================================
            // LIGHTING
            // ============================================
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffeedd, 1.2);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.receiveShadow = true;
            directionalLight.shadow.mapSize.width = 1024; // Lower for performance
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xff69b4, 0.8, 50);
            pointLight.position.set(-5, 5, 5);
            scene.add(pointLight);
            
            const backLight = new THREE.PointLight(0x8866cc, 0.3);
            backLight.position.set(0, 0, -10);
            scene.add(backLight);

            // ============================================
            // CREATE PETAL AND ROSE (unchanged from working version)
            // ============================================
            function createRosePetal() {
                const points = [];
                points.push(new THREE.Vector2(0.0, 0.0));
                points.push(new THREE.Vector2(0.15, 0.1));
                points.push(new THREE.Vector2(0.25, 0.3));
                points.push(new THREE.Vector2(0.3, 0.5));
                points.push(new THREE.Vector2(0.32, 0.7));
                points.push(new THREE.Vector2(0.28, 0.9));
                points.push(new THREE.Vector2(0.2, 1.1));
                points.push(new THREE.Vector2(0.1, 1.2));
                points.push(new THREE.Vector2(0.05, 1.15));
                points.push(new THREE.Vector2(0.0, 1.0));
                
                const petalGeometry = new THREE.LatheGeometry(points, 16, 0, Math.PI);
                return petalGeometry;
            }

            class Rose {
                constructor() {
                    this.group = new THREE.Group();
                    this.petalMeshes = [];
                    this.time = 0;
                    
                    this.createStem();
                    this.createLeaves();
                    this.createFlower();
                    
                    scene.add(this.group);
                }
                
                createStem() {
                    const stemGeometry = new THREE.CylinderGeometry(0.08, 0.12, 5, 12);
                    const stemMaterial = new THREE.MeshStandardMaterial({
                        color: 0x2d5016,
                        roughness: 0.6,
                        metalness: 0.05,
                        side: THREE.DoubleSide
                    });
                    
                    const stem = new THREE.Mesh(stemGeometry, stemMaterial);
                    stem.castShadow = true;
                    stem.receiveShadow = true;
                    stem.position.y = -2.5;
                    this.group.add(stem);
                    
                    const thornMaterial = new THREE.MeshStandardMaterial({
                        color: 0x1a3a0a,
                        roughness: 0.5
                    });
                    
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const thornGeometry = new THREE.ConeGeometry(0.025, 0.5, 6);
                        const thorn = new THREE.Mesh(thornGeometry, thornMaterial);
                        thorn.castShadow = true;
                        
                        thorn.position.set(
                            Math.cos(angle) * 0.12,
                            -2 - Math.random() * 2.5,
                            Math.sin(angle) * 0.12
                        );
                        thorn.rotation.z = angle + Math.PI / 4;
                        this.group.add(thorn);
                    }
                }
                
                createLeaves() {
                    const leafPoints = [];
                    leafPoints.push(new THREE.Vector2(0.0, 0.0));
                    leafPoints.push(new THREE.Vector2(0.15, 0.2));
                    leafPoints.push(new THREE.Vector2(0.25, 0.4));
                    leafPoints.push(new THREE.Vector2(0.3, 0.6));
                    leafPoints.push(new THREE.Vector2(0.28, 0.8));
                    leafPoints.push(new THREE.Vector2(0.2, 0.95));
                    leafPoints.push(new THREE.Vector2(0.1, 0.98));
                    leafPoints.push(new THREE.Vector2(0.0, 0.85));
                    
                    const leafGeometry = new THREE.LatheGeometry(leafPoints, 12, 0, Math.PI);
                    const leafMaterial = new THREE.MeshStandardMaterial({
                        color: 0x4a7c4e,
                        roughness: 0.6,
                        metalness: 0.05,
                        side: THREE.DoubleSide
                    });
                    
                    for (let i = 0; i < 5; i++) {
                        const leaf = new THREE.Mesh(leafGeometry, leafMaterial.clone());
                        leaf.castShadow = true;
                        leaf.receiveShadow = true;
                        
                        leaf.position.set(
                            Math.cos(i * Math.PI / 2.5) * 0.7,
                            -1.0 - i * 0.5,
                            Math.sin(i * Math.PI / 2.5) * 0.4
                        );
                        
                        leaf.rotation.y = i * (Math.PI / 2.5);
                        leaf.rotation.z = Math.PI / 6 + i * 0.2;
                        leaf.scale.set(1.3, 1.2, 1.0);
                        
                        this.group.add(leaf);
                    }
                }
                
                createFlower() {
                    const pistilGeometry = new THREE.SphereGeometry(0.12, 20, 20);
                    const pistilMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffdd00,
                        roughness: 0.3,
                        metalness: 0.3,
                        emissive: 0xffaa00,
                        emissiveIntensity: 0.3
                    });
                    const pistil = new THREE.Mesh(pistilGeometry, pistilMaterial);
                    pistil.castShadow = true;
                    pistil.receiveShadow = true;
                    this.group.add(pistil);
                    
                    const stamenCount = 16;
                    const stamenMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffcc00,
                        roughness: 0.4,
                        metalness: 0.1
                    });
                    
                    for (let i = 0; i < stamenCount; i++) {
                        const angle = (i / stamenCount) * Math.PI * 2;
                        const stamenGeometry = new THREE.ConeGeometry(0.015, 0.25, 5);
                        const stamen = new THREE.Mesh(stamenGeometry, stamenMaterial);
                        stamen.castShadow = true;
                        
                        stamen.position.set(
                            Math.cos(angle) * 0.16,
                            0.08,
                            Math.sin(angle) * 0.16
                        );
                        stamen.rotation.z = angle;
                        this.group.add(stamen);
                    }
                    
                    const petalGeometry = createRosePetal();
                    
                    const petalColors = [
                        0xc41e3a, 0xd62828, 0xee4b2b, 0xff0000, 
                        0xff1493, 0xff69b4, 0xdc143c, 0xb21e35
                    ];
                    
                    const layers = [
                        { count: 5, radius: 0.35, yOffset: 0.05, scale: 0.8 },
                        { count: 8, radius: 0.5, yOffset: 0.08, scale: 1.0 },
                        { count: 12, radius: 0.65, yOffset: 0.10, scale: 1.2 },
                        { count: 16, radius: 0.78, yOffset: 0.12, scale: 1.35 }
                    ];
                    
                    layers.forEach((layer, layerIndex) => {
                        for (let i = 0; i < layer.count; i++) {
                            const angle = (i / layer.count) * Math.PI * 2 + (layerIndex * Math.PI / 8);
                            
                            const petalMaterial = new THREE.MeshStandardMaterial({
                                color: petalColors[i % petalColors.length],
                                roughness: 0.5,
                                metalness: 0.1,
                                side: THREE.DoubleSide,
                                emissive: new THREE.Color(petalColors[i % petalColors.length]).multiplyScalar(0.2),
                                emissiveIntensity: 0.2
                            });
                            
                            const petalMesh = new THREE.Mesh(petalGeometry, petalMaterial);
                            petalMesh.castShadow = true;
                            petalMesh.receiveShadow = true;
                            
                            petalMesh.position.set(
                                Math.cos(angle) * layer.radius,
                                layer.yOffset,
                                Math.sin(angle) * layer.radius
                            );
                            
                            petalMesh.rotation.y = angle;
                            petalMesh.rotation.x = -Math.PI / 3 + (layerIndex * 0.15);
                            petalMesh.rotation.z = (Math.random() - 0.5) * 0.4;
                            
                            petalMesh.scale.set(layer.scale, layer.scale, layer.scale);
                            
                            this.group.add(petalMesh);
                            this.petalMeshes.push({
                                mesh: petalMesh,
                                baseRotation: {
                                    x: petalMesh.rotation.x,
                                    y: petalMesh.rotation.y,
                                    z: petalMesh.rotation.z
                                }
                            });
                        }
                    });
                    
                    const sepalGeometry = new THREE.ConeGeometry(0.15, 0.6, 6);
                    const sepalMaterial = new THREE.MeshStandardMaterial({
                        color: 0x3d7d3d,
                        roughness: 0.6,
                        side: THREE.DoubleSide
                    });
                    
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const sepal = new THREE.Mesh(sepalGeometry, sepalMaterial.clone());
                        sepal.castShadow = true;
                        sepal.receiveShadow = true;
                        
                        sepal.position.set(
                            Math.cos(angle) * 0.25,
                            -0.2,
                            Math.sin(angle) * 0.25
                        );
                        
                        sepal.rotation.y = angle;
                        sepal.rotation.x = Math.PI / 3;
                        sepal.scale.set(0.8, 0.8, 0.7);
                        
                        this.group.add(sepal);
                    }
                }
                
                update(deltaTime) {
                    this.time += deltaTime;
                    
                    this.group.rotation.y += 0.003;
                    this.group.rotation.x = Math.sin(this.time * 0.3) * 0.1;
                    
                    this.petalMeshes.forEach((petal, index) => {
                        const sway = Math.sin(this.time * 0.5 + index * 0.3) * 0.02;
                        const flutter = Math.sin(this.time * 1.2 + index * 0.5) * 0.015;
                        
                        petal.mesh.rotation.z = petal.baseRotation.z + sway + flutter;
                        petal.mesh.rotation.x = petal.baseRotation.x + Math.sin(this.time * 0.4 + index) * 0.01;
                    });
                }
            }

            rose = new Rose();
            lastTime = Date.now();

            // ============================================
            // MOUSE CONTROLS (with touch support)
            // ============================================
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            function handleDragStart(x, y) {
                if (!rose) return;
                isDragging = true;
                previousMousePosition = { x, y };
            }
            
            function handleDragMove(x, y) {
                if (isDragging && rose) {
                    const deltaX = x - previousMousePosition.x;
                    const deltaY = y - previousMousePosition.y;
                    
                    rose.group.rotation.y += deltaX * 0.005;
                    rose.group.rotation.x += deltaY * 0.005;
                    
                    previousMousePosition = { x, y };
                }
            }
            
            function handleDragEnd() {
                isDragging = false;
            }
            
            // Mouse events
            document.addEventListener('mousedown', (e) => handleDragStart(e.clientX, e.clientY));
            document.addEventListener('mousemove', (e) => handleDragMove(e.clientX, e.clientY));
            document.addEventListener('mouseup', handleDragEnd);
            
            // Touch events
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length) {
                    handleDragStart(e.touches[0].clientX, e.touches[0].clientY);
                }
            });
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length) {
                    e.preventDefault();
                    handleDragMove(e.touches[0].clientX, e.touches[0].clientY);
                }
            });
            document.addEventListener('touchend', handleDragEnd);

            // Zoom with scroll and pinch
            document.addEventListener('wheel', (e) => {
                if (camera) {
                    e.preventDefault();
                    camera.position.z += e.deltaY * 0.005;
                    camera.position.z = Math.max(2, Math.min(12, camera.position.z));
                }
            }, { passive: false });
            
            // Pinch zoom for touch
            let initialDistance = 0;
            document.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });
            
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2 && camera) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (initialDistance > 0) {
                        const delta = initialDistance - distance;
                        camera.position.z += delta * 0.01;
                        camera.position.z = Math.max(2, Math.min(12, camera.position.z));
                        initialDistance = distance;
                    }
                }
            });
        }

        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
            requestAnimationFrame(animate);
            
            if (rose && scene && camera && renderer) {
                const now = Date.now();
                const deltaTime = (now - lastTime) / 1000;
                lastTime = now;
                
                rose.update(deltaTime);
                
                if (backgroundElements) {
                    if (backgroundElements.stars) {
                        backgroundElements.stars.rotation.y += 0.0001;
                        backgroundElements.stars.rotation.x += 0.00005;
                    }
                    if (backgroundElements.twinkles) {
                        backgroundElements.twinkles.rotation.y += 0.00015;
                    }
                }
                
                renderer.render(scene, camera);
            }
        }

        // Start animation loop
        animate();
    </script>
</body>
</html>